(ns mobility-dpu.core
  (:require [cheshire.core]
            [cheshire.custom]
            [taoensso.timbre :as timbre]
            [mobility-dpu.hmm :as hmm]
            [mobility-dpu.summary :as summary]
            [mobility-dpu.datapoint :refer [daily-summary-datapoint daily-segments-datapoint]]
            monger.joda-time
            )
  (:use [aprint.core])
  )

(timbre/refer-timbre)


(defprotocol Segmentor
  (source-name [this] "Return the name of the source this segmentor is designed for")
  (get-activity-dat [this user] "Return a list of all the raw activity samples")
  (get-location-dat [this user] "Return a list of all the raw location samples")
  (transition-matrix [this] "The initial state transition matrix")
  (emission-prob [this state observation] "Return the prop of P(observation|state) namely given the hidden state the prob of having the observation")
  (init-pi [this] "The initial prob of each state at time 0")
  (post-process [this segments] "Post process function after segments have been generated by the HMM")
  )








(defn segmentation
  "Segment a user's data using the given segmentor"
  [segmentor user]

      (let [act-dat (sort-by :timestamp (get-activity-dat segmentor user))
            loc-dat (sort-by :timestamp (get-location-dat segmentor user))
            ; remove the location samples that have low accuracy
            locations (filter #(< (get-in % [:location :accuracy]) 75) loc-dat)
            ; break data points into small segments by gaps
            segments (hmm/downsample-and-segment-by-gaps act-dat)
            ; further break a segment into activity segments, each of which represent a continuos activity episode
            inferred-segments (hmm/to-inferred-segments segments
                                                        (transition-matrix segmentor)
                                                        #(emission-prob segmentor %1 %2)
                                                        (init-pi segmentor))
            ; execure the post process function
            inferred-segments (post-process segmentor inferred-segments)
            ; merge activity segments with location datapoints by time
            inferred-segments (hmm/merge-segments-with-location inferred-segments locations)
            ]
        ; remove those 0-second segment.
        (filter #(> (:duration-in-seconds %) 0) inferred-segments)

))



(comment       ; FIXME not sure if the following function is needed anymore.
  (map (fn [{:keys [displacement-speed inferred-activity duration-in-seconds] :as seg}]
         ; deal with subway cases
         (if (and (= inferred-activity :still)
                  displacement-speed
                  (>= displacement-speed 1)
                  (> duration-in-seconds 120)
                  )
           (assoc seg :inferred-activity :in_vehicle)
           seg)
         ) act-loc))







